{-# LANGUAGE Trustworthy #-}
{-# LANGUAGE ConstraintKinds,
             FlexibleContexts,
             DeriveDataTypeable #-}

{- |


-}

module Hails.Database.Core (
  -- * Collection
    CollectionName
  , CollectionSet
  , Collection, colName, colLabel, colClearance, colPolicy
  , collection, collectionP
  -- * Database
  , DatabaseName
  , Database, databaseName, databaseLabel, databaseCollections
  -- * Policies
  , CollectionPolicy(..)
  , FieldPolicy(..)
  , isSearchableField
  , searchableFields
  -- ** Applying policies
  , applyCollectionPolicyP
  -- ** Policy errors
  , PolicyError(..)
  -- * Labeled documents
  , LabeledHsonDocument 
  -- * Hails DB monad
  , DBAction, DBActionState(..)
  , runDBAction, evalDBAction
  , getDatabase, getDatabaseP
  , associateCollection, associateCollectionP
  , setDatabaseLabel, setDatabaseLabelP
  , setCollectionsLabel, setCollectionsLabelP
  -- ** Database system configuration
  , Pipe, AccessMode(..), master, slaveOk
  -- ** Exception thrown by failed database actions
  , Failure(..)
  ) where

import qualified Data.List as List
import           Data.Map (Map)
import qualified Data.Map as Map
import qualified Data.Traversable as T
import           Data.Maybe
import           Data.Typeable

import           Control.Monad
import           Control.Monad.Trans.State
import           Control.Exception (Exception(..))

import           LIO
import           LIO.DCLabel

import           Hails.Data.Hson
import           Hails.Data.Hson.TCB
import           Hails.Database.TCB

--
-- Collection
--

-- | Create a 'Collection' given a name, label, clearance, and policy.
-- The supplied collection label and clearance must be above the current
-- label and below the current clearance as enforced by 'guardAlloc'.
collection :: MonadDC m
           => CollectionName  -- ^ Collection name
           -> DCLabel         -- ^ Collection label
           -> DCLabel         -- ^ Collection clearance
           -> CollectionPolicy-- ^ Collection policy
           -> m Collection
collection = collectionP noPriv

-- | Same as 'collection', but uses privileges when comparing the
-- supplied collection label and clearance with the current label and
-- clearance.
collectionP :: MonadDC m 
            => DCPriv           -- ^ Privileges
            -> CollectionName   -- ^ Collection name
            -> DCLabel          -- ^ Collection label
            -> DCLabel          -- ^ Collection clearance
            -> CollectionPolicy -- ^ Collection policy
            -> m Collection
collectionP p n l c pol = do
  guardAllocP p l
  guardAllocP p c
  return $ collectionTCB n l c pol

--
-- Policies
--

-- | Returns 'True' if the field policy is a 'SearchableField'.
isSearchableField :: FieldPolicy -> Bool
isSearchableField SearchableField = True
isSearchableField _ = False

-- | Get the list of names corresponding to 'SearchableField's.
searchableFields :: CollectionPolicy -> [FieldName]
searchableFields policy =
  Map.keys $ Map.filter isSearchableField fps
  where fps = fieldLabelPolicies policy

-- | Apply a collection policy the given document, using privileges
-- when labeling the document and performing label comparisons.
-- The labeling proceeds as follows:
--
-- * If two fields have the same 'FieldName', only the first is kept.
--   This filtering is only perfomed at the top level.
--
-- * Each policy labeled value ('HsonLabeled') is labled if the policy
--   has not been applied. If the value is already labeled, then the
--   label is checked to be equivalent to that generated by the policy.
--   In both cases a failure results in 'PolicyViolation' being thrown;
--   the actual error must be hidden to retain the opaqueness of
--   'PolicyLabeled'.
--
--
--   /Note:/ For each 'FieldNamed' in the policy there /must/ be a
--   field in the document corresponding to it. Moreover its \"type\"
--   must be correct: all policy labeled values must be 'HsonLabeled'
--   values and all searchable fields must be 'HsonValue's. The @_id@
--   field is always treated as a 'SearchableField'.
--
-- * The resulting document (from the above step) is labeled according
--   to the collection policy.
--
-- The labels on 'PolicyLabeled' values and the document must be bounded
-- by the current label and clearance as imposed by 'guardAllocP'.
-- Additionally, these labels must flow to the label of the collection
-- clearance. (Of course, in both cases privileges are used to allow for
-- more permissive flows.)
applyCollectionPolicyP :: MonadDC m
                       => DCPriv        -- ^ Privileges
                       -> Collection    -- ^ Collection and policies
                       -> HsonDocument  -- ^ Document to apply policies to
                       -> m (LabeledHsonDocument)
applyCollectionPolicyP p col doc0 = liftLIO $ do
  let doc1 = List.nubBy (\f1 f2 -> fieldName f1 == fieldName f2) doc0
  typeCheckDocument fieldPolicies doc1
  withClearance (colClearance col) $ do
    -- Apply fied policies:
    doc2 <- T.for doc1 $ \f@(HsonField n v) ->
      case v of
        (HsonValue _) -> return f
        (HsonLabeled pl) -> do
          -- NOTE: typeCheckDocument MUST be run before this:
          let (FieldPolicy fieldPolicy) = fieldPolicies Map.! n
              l = fieldPolicy doc1
          case pl of
            (NeedPolicyTCB bv) -> do
              lbv <- labelP p l bv `onException` throwLIO PolicyViolation
              return (n -: hasPolicy lbv)
            (HasPolicyTCB lbv) -> do 
              unless (labelOf lbv == l) $ throwLIO PolicyViolation
              return f
    -- Apply document policy:
    labelP p (docPolicy doc2) doc2
  where docPolicy     = documentLabelPolicy . colPolicy $ col
        fieldPolicies = fieldLabelPolicies  . colPolicy $ col

-- | This function \"type-checks\" a document against a set of policies.
-- Specifically, it checks that the set of policy labeled values is the
-- same between the policy and document, and searchable fields are not
-- policy labeled.
typeCheckDocument :: Map FieldName FieldPolicy -> HsonDocument -> DC ()
typeCheckDocument ps doc = do
  -- Check that every policy-named value is well-typed
  void $ T.for psList $ \(k,v) -> do
    let mv' = look k doc
        v' = fromJust mv'
    unless (isJust mv') $ throwLIO $ TypeError $ 
      "Missing field with name " ++ show k
    case v of
      SearchableField -> isHsonValue   k v'
      FieldPolicy _   -> isHsonLabeled k v'
  -- Check that no policy-labeled values not named in the policy
  -- exist:
  let doc' = exclude (map fst psList) doc
  unless (isBsonDoc doc') $ throwLIO $ TypeError $
     "Fields " ++ show (map fieldName doc') ++ " should NOT be policy labeled."
        where psList = Map.toList ps
              isHsonValue _ (HsonValue _) = return ()
              isHsonValue k _ = throwLIO $ TypeError $
                show k ++ " should NOT be policy labeled"
              isHsonLabeled _ (HsonLabeled _) = return ()
              isHsonLabeled k _ = throwLIO $ TypeError $
                show k ++ " should be policy labeled"


--
-- Policy error
--

-- | A document policy error.
data PolicyError = TypeError String -- ^ Document is not \"well-typed\"
                 | PolicyViolation  -- ^ Policy has been violated
                 deriving (Show, Typeable)

instance Exception PolicyError

--
-- Labeled documents
--
-- | A labeled 'HsonDocument'.
type LabeledHsonDocument = DCLabeled HsonDocument

--
-- DB monad
--

-- | Execute a database action returning the final result and state.
-- In general, code should instead use 'evalDBAction'. This function
-- is primarily used by trusted code to initialize a policy module
-- which may have modified the underlying database.
runDBAction :: DBAction a -> DBActionState -> DC (a, DBActionState)
runDBAction = runStateT . unDBAction

-- | Execute a database action returning the final result.
evalDBAction :: DBAction a -> DBActionState -> DC a
evalDBAction a s = fst `liftM` runDBAction a s

-- | Get the underlying database. Must be able to read from the
-- database as enforced by applying 'taint' to the database label.
-- This is required because the database label protects the
-- label on collections which can be projected given a 'Database'
-- value.
getDatabase :: DBAction Database
getDatabase = getDatabaseP noPriv

-- | Same as 'getDatabase', but uses privileges when raising the
-- current label.
getDatabaseP :: DCPriv -> DBAction Database
getDatabaseP p = do
  db <- dbActionDB `liftM` getActionStateTCB
  taintP p (databaseLabel db)
  return db

-- | Set the label of the underlying databse. The supplied label must
-- be bounded by the current label and clearance as enforced by
-- 'guardAlloc'. In addition, the code modying the database label must
-- be permitted by the policy module that owns the databse.
-- Specifically, the new label must be equivalent to the existing
-- database label. As such, most code should use 'setDatbaseLabelP',
-- which takes aprivilege argument that can be used in this
-- comparison.
setDatabaseLabel :: DCLabel -> DBAction ()
setDatabaseLabel = setDatabaseLabelP noPriv

-- | Same as 'setDatabaseLabel', but uses privileges when performing
-- label comparisons. If a policy module wishes to allow other policy
-- modules or apps to access the underlying databse it must use 
-- @setDatabaseLabelP@ to \"downgrade\" the database label, which by
-- default only allows the policy module to access any of the
-- contents (including collection map).
setDatabaseLabelP :: DCPriv    -- ^ Set of privileges
                  -> DCLabel   -- ^ New database label
                  -> DBAction ()
setDatabaseLabelP p l = do
  guardAllocP p l
  ldb <- (databaseLabel . dbActionDB) `liftM` getActionStateTCB
  unless (ldb `flowsTo` l && l `flowsTo` ldb) $ throwLIO InsufficientPrivs
  setDatabaseLabelTCB l
    where flowsTo l1 l2 = canFlowToP p l1 l2

-- | The collections label protects the collection map of the
-- database. It is used to restrict who can name a collection in the
-- database and who can modify the underlying collection map (e.g., by
-- associating a new collection with the database). The policy module
-- may change the default collections label, which limits access to
-- the policy module alone, using @setCollectionsLabel@.
--
-- The new label must be bounded by the current label and clearance as
-- checked by 'guardAlloc', the current label must flow to the label of
-- the database, and finally the new collection label must be equivalent
-- to the existing one. The last requirement is imposed so as to
-- prevent code other than the policy module from changing the label
-- on first account. Hence, in most cases code should use
-- 'setCollectionsLabelP'.
setCollectionsLabel :: DCLabel -> DBAction ()
setCollectionsLabel = setCollectionsLabelP noPriv

-- | Same as 'setCollectionsLabel', but uses the supplied privileges
-- when performing label comparisons.
setCollectionsLabelP :: DCPriv      -- ^ Set of privileges
                     -> DCLabel     -- ^ New collections label
                     -> DBAction ()
setCollectionsLabelP p l = do
  guardAllocP p l
  db  <-  dbActionDB `liftM` getActionStateTCB
  guardWriteP p (databaseLabel db)
  let lcs = labelOf . databaseCollections $ db
  unless (lcs `flowsTo` l && l `flowsTo` lcs) $ throwLIO InsufficientPrivs
  setCollectionsLabelTCB l
    where flowsTo l1 l2 = canFlowToP p l1 l2
  

-- | Given a newly created collection, associate the collection with the
-- underlying database. Several IFC rules must be respected for this
-- function to succeed:
-- 
-- 1. The computation must be able to read the database collection map
--    protected by the database label. The guard 'taint' is used to
--    guarantee this and raise the current label appropriately.
-- 
-- 2. The computation must be able to modify the database collection map.
--    The guard 'guardWrite' is used to guarantee that the current label
--    is essentially equal to the collection map label.
associateCollection :: Collection   -- ^ New collection
                    -> DBAction ()
associateCollection = associateCollectionP noPriv

-- | Same as 'associateCollection', but uses privileges when
-- performing label comparisons and raising the current label.
associateCollectionP :: DCPriv       -- ^ Privileges
                     -> Collection   -- ^ New collection
                     -> DBAction ()  -- ^ New database
associateCollectionP p col = do
  db <- dbActionDB `liftM` getActionStateTCB
  taintP p $ databaseLabel db
  guardWriteP p $ labelOf (databaseCollections db)
  associateCollectionTCB col
